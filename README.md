# Rick & Morty
### Hi there, I'm Muharrem <img src = "https://raw.githubusercontent.com/MartinHeinz/MartinHeinz/master/wave.gif" width = "42"> 
#### Thank You for taking the time to view my repository 

## <h2> About This App <img src = "https://c.tenor.com/JsoERRQcZqYAAAAi/thumbs-up-joypixels.gif" width = "42"></h2>
This application is an entertainment application where you can find information about the famous cartoon series Rick and Morty. The main purpose of this application is to show developers how to develop the protocol, how to implement user interface and unit tests, and how to do dependency injection. In addition to these, you can learn how to interface with programming completely from this application. The application opens with a welcome screen. It features the Rick And Morty logo and a welcome message. The message here is "Welcome!" When the user first opens the app appears as "Hello!" looks. Here, the number of times the user has opened the application is recorded with the UserDefaults class. Then the welcome text changes accordingly. Then, after 3 seconds with DispatchQueue.main.asyncAfter, the main application is switched. The main application has a Tab Controller. The first tab shows the characters, while the second tab shows the episodes of the series. When you look at the screen on the first tab, you can see the location names under the Navigation heading at the top and the characters below it. First of all, location names are taken here. This list consists of a horizontal scrolling CollectionView. The location information received after the API request is mapped with the newly created LocationNameAndResidents structure. The mapped data is transferred to an array. Then it is sent to the main view with the created protocol. While scrolling the location list, after the first 20 locations, a spinner spins at the end of the list and takes the information of another 20 locations. In this way, the pagination processes are carried out without interruption. To do this, we first created a ReusableView using the UICollectionReusableView class. Then, we ensured the use of this view by using the viewForSupplementaryElementOfKind function belonging to the UICollectionView.
  Then, with the scrollViewDidScroll function of the UIScrollView class, we calculated the view values at the end of the list mathematically and showed the spinner accordingly. Then, we took the pagination URLs from the API with the fetchMoreLocation function we wrote in the ViewModel and made new requests. In this way, we have finished the pagination process. As the user clicks on the location buttons, character IDs are parsed from the character URLs coming from the API in the background. The parsed character IDs are sent to the character view with the help of a protocol. According to the data received here, an API request is made on the viewModel page. The character data received after the request is transferred to the view with the help of the protocol. Since some of the data coming here will not be displayed actively on the screen, only the necessary data is obtained by creating the RMCharacterCollectionViewCellViewModel. Therefore, the data coming in the ViewModel file is stored as RMCharacterCollectionViewCellViewModel. So this data is being sent. The character cell displays the character's name, picture, and status. A special color is applied around the cells with the received gender information. This color is determined by gender, male, female, and unknown. The character view appears as a list of CollectionViews, just like the location. Here we set it with the sizeForItemAt function of the UICollectionViewLayout class to make it appear binary. Here we used the didSelectItemAt function so that the user can see the details of the clicked character. Here we first get the character that the user clicked. Then, we sent the character received with the protocol we wrote to the detail page. On the detail page, we created sections for character pictures, information, and series episodes. We made these sections by making use of the NSCollectionLayoutSection class. It has also been made more organized by creating separate ViewModel files for each section. The download process is performed according to the URL received in the ViewModel file created for the character image. To do this, we created a class that we can use later. The RMImageDownloader class first checks if the image is in the cache. Then it sends it, if any. If not, it downloads the image with the given URL. Thus, the character image on the character detail page is updated. We also created a ViewModel for character information. Here we have set the title, content, icons, and colors to be used with an enum. Finally, we created a ViewModel for the array segments. Here, we got the series episode data belonging to the character. First of all, episode IDs that come with character information were separated. Then the request was made with the parsed data. Here, the request is not thrown unless the user scrolls the CollectionView while making a request. In other words, when the character detail page is opened, the episodes are taken in twos. In this way, unnecessary API requests are prevented. Another point to consider here is the way we transmit data.While creating the CollectionView cell, we provide viewModel submission with the configure function. So we need to run it inside the configure function. Because of this situation, we preferred such a transmission method. In this way, we first created a @escaping function. Then we created a protocol and created variables for the name of the episode, which episode it was, and the air date. Then, we extended our EpisodeInfo model, which we will use with this protocol, with the RMCharacterDetailViewEpisodesRendering protocol. In this way, we were able to use our model with the protocol. We gave the values of the next episode to the dataBlock variable we created and equated them to the block variable we created in the registerData function. In this way, now, when ViewModel.registerData is called in the configure function, a completion block will be opened for us and we can use the incoming data for labels. If the user touches one of these episodes, of course, he can get information about that Episode with the Episode detail page. As we said, the second tab of the Tab Controller is the Episode screen. Here we used a TableView. We also used a pagination as in the location view. When the user scrolls down, a spinner appears and receives new episode information. We used the TableView's tableFooterView method to show a spinner at the bottom of the TableView list. Thanks to this, we were able to create a custom field at the end of the list. We also used accessoryType to further indicate that clicking on the elements in the list allows you to go to the detail page. When the user clicks on the desired episode from the list, the episode is retrieved and sent to the detail page with the protocol we wrote. In this way, the user can see the episode details. On this page, the episode's name, information, broadcast date, and creation date are used with the same type of episode, while the characters in the episode are shown just like on the main screen. With the written protocol, the user clicks on the desired character and is directed to the detail page. Also, a date converter class named RMDateFormatter has been written for formatting the creation time. Thanks to this class, which is used as a singleton, the dates coming directly from the API can be sent to the screen in an understandable way. For the service of the application, an RMRequest class was created first. In this way, it became easier to assign features such as endpoint controls, paths, and queries. For the API service, we used the generic concept. In this way, we can send requests with any structure that supports the Codable feature, regardless of the type. In addition, we inherited our service to the RMApiCallService protocol to facilitate unit test writing and Dependency Injection principles. In this way, we can process mock services during testing. Apart from these, we wrote an extension to add multiple subviews at the same time. In this way, multiple subviews can be added to the main view at the same time. Finally, we wrote unit and UI tests in our application. We checked whether it works with mock services and mock values in unit tests. In the UI tests, the functionality of the application was tested. Finally, we completed the application by changing the screen name and icon of our application, which passed the tests successfully.

<a href="https://rickandmortyapi.com/" target="_blank">Visit Rick and Morty API</a><br>

<h2> Used Technologies <img src = "https://media2.giphy.com/media/QssGEmpkyEOhBCb7e1/giphy.gif?cid=ecf05e47a0n3gi1bfqntqmob8g9aid1oyj2wr3ds3mg700bl&rid=giphy.gif" width = "42"> </h2>
<div class="row">
      <div class="column">
<img width ='72px' src 
     ='https://raw.githubusercontent.com/MuharremKoroglu/MuharremKoroglu/main/swift-icon.svg'>
  </div>
</div>

<h2> Used Language <img src = "https://media.giphy.com/media/Zd6jPg8hcp4Q3vrvjo/giphy.gif" width = "42"> </h2>
<div class="row">
      <div class="column">
<img width ='82px' src 
     ='https://raw.githubusercontent.com/MuharremKoroglu/Bitcoin/main/Flag_of_the_United_Kingdom.svg'>
  </div>
</div>

<h2> Images <img src = "https://media2.giphy.com/media/psneItdLMpWy36ejfA/source.gif" width = "62"> </h2>
  <div class="column">



https://github.com/MuharremKoroglu/RickAndMorty/assets/68854616/829f2b6f-b50f-4f44-acf1-3079e0751b90



  </div>
<h2> Connect with me <img src='https://raw.githubusercontent.com/ShahriarShafin/ShahriarShafin/main/Assets/handshake.gif' width="100"> </h2>
<a href = 'mailto:muharremkoroglu245@gmail.com'> <img align="center" width = '32px' align= 'center' src="https://raw.githubusercontent.com/MuharremKoroglu/MuharremKoroglu/main/gmail-logo-2561.svg"/></a> &nbsp;
<a href = 'https://www.linkedin.com/in/muharremkoroglu/'> <img align="center" width = '32px' align= 'center' src="https://raw.githubusercontent.com/rahulbanerjee26/githubAboutMeGenerator/main/icons/linked-in-alt.svg"/></a> &nbsp;
<a href = 'https://muharremkoroglu.medium.com/'> <img align="center" width = '32px' align= 'center' src="https://raw.githubusercontent.com/rahulbanerjee26/githubAboutMeGenerator/main/icons/medium.svg"/></a> &nbsp;
<a href="https://www.instagram.com/m.koroglu99/" target="blank"><img align="center" src="https://raw.githubusercontent.com/rahuldkjain/github-profile-readme-generator/master/src/images/icons/Social/instagram.svg" alt="_._.adam._"  width="32px" align= 'center' /></a> &nbsp;
<a href = 'https://synta-x.com/'> <img align="center" width = '32px' align= 'center' src="https://raw.githubusercontent.com/MuharremKoroglu/MuharremKoroglu/main/internet-svgrepo-com%20(2).svg"/></a> &nbsp;




